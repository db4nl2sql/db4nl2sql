from util import util, const
import re
import sqlglot
from sqlglot import exp

class SQLGenerator:
    def __init__(self, setting, logger, rank, llm):
        self.setting = setting
        self.logger = logger
        self.rank = rank
        self.llm = llm


    def generate_SQL(self, qnl: str, schema_info: str, evidence: str, few_shot_prompt: str = None) -> str:
        """
        [params] qnl: single natural language question
                 schema info: text representation schema info for the corresponding db_id
        [return] sql query generated by llm
        """


        general_tip = const.general_tip

        if len(evidence) < 1:
            evidence = ""

        prompt = const.final_prompt.format(general_tip=general_tip, schema_info=schema_info,
                                        few_shot_prompt=few_shot_prompt, evidence=evidence, qnl=qnl)
        response = util.llm_call_max4096(self.llm, self.setting.model, prompt)

        if self.setting.logging and self.logger.PROMPT_FILE is not None:
            self.logger.PROMPT_FILE.writelines("\n***** FINAL PROMPT ***** \n" + prompt + '\n')
            self.logger.PROMPT_FILE.writelines("\n***** RESPONSE ***** \n" + str(response))
            self.logger.PROMPT_FILE.writelines("\n\n***** TOKEN INFO ***** \n" + str(response.usage) + '\n')
            self.logger.calculate_token(response)

        if self.setting.model == "llama3.1:8b" or self.setting.model == "llama3.1:70b" or self.setting.model == "llama3.1:405b": # 
            qsql = response

        else: #gpt 
            qsql = response.choices[0].message.content.replace('\n', ' ')
        
        # 
        sql_pattern = r"```sql\n(.*?)\n```" 
        match = re.search(sql_pattern, qsql, re.DOTALL)
        if match: 
            qsql = match.group(1).strip() 

        if qsql.startswith("```sql"):
            qsql = qsql.split("```sql")[1].split("```")[0].strip()
        if not qsql.upper().startswith("SELECT"):
            qsql = 'SELECT ' + qsql

        return qsql
    

    def generate_SQL_for_view(self, db_id, setting, logger, llm, qnl: str, schema_info: str, evidence: str, v_type:str) -> str:
        # gen-tip
        if v_type == "uv":
            general_tip = const.general_tip_uv
        else:
            general_tip = const.general_tip

        # evidence
        if len(evidence) < 1:
            evidence = ""

        if v_type == "rv":
            renamed_views = setting.renamed_view.get(db_id, [])  

            for rv in renamed_views:
                column_mapping = rv.get("column_mapping", [])
                for (old_col, new_col) in column_mapping:

                    pattern = r'\b' + re.escape(old_col) + r'\b'

                    if re.search(pattern, evidence):
                        evidence = re.sub(pattern, f"`{new_col}`", evidence)
                    # if re.search(pattern, qnl):
                    #     qnl = re.sub(pattern, f"`{new_col}`", qnl)
        

        prompt = const.final_prompt.format(
            general_tip=general_tip,
            schema_info=schema_info,  
            few_shot_prompt="",
            evidence=evidence,
            qnl=qnl
        )
        response = util.llm_call_max4096(llm, setting.model, prompt)

        if setting.logging and logger.PROMPT_FILE is not None:
            logger.PROMPT_FILE.writelines("\n***** FINAL PROMPT ***** \n" + prompt + '\n')
            logger.PROMPT_FILE.writelines("\n***** RESPONSE ***** \n" + str(response))
            logger.PROMPT_FILE.writelines("\n\n***** TOKEN INFO ***** \n" + str(response.usage) + '\n')
            logger.calculate_token(response)

        if setting.model in ["llama3.1:8b", "llama3.1:70b", "llama3.1:405b"]:
            qsql = response
        else:
            qsql = response.choices[0].message.content.replace('\n', ' ')

        sql_pattern = r"```sql\n(.*?)\n```"
        match = re.search(sql_pattern, qsql, re.DOTALL)
        if match:
            qsql = match.group(1).strip()

        if qsql.startswith("```sql"):
            qsql = qsql.split("```sql")[1].split("```")[0].strip()

        if not qsql.upper().startswith("SELECT"):
            qsql = 'SELECT ' + qsql

        return qsql


    def quote_if_needed(self, identifier: str) -> str:
        if identifier.startswith("`") and identifier.endswith("`"):
            return identifier

        if re.match(r'^[A-Za-z_][A-Za-z0-9_]*$', identifier):
            return identifier
        else:
            return f"`{identifier}`"


    def decompose_to_base_table_rv(self, sql_query: str, db_id: str) -> str:
        renamed_infos = self.setting.renamed_view.get(db_id, [])

        rename_map_table = {}
        for info in renamed_infos:
            create_view_sql = info["renamed_view_ddl"]
            match = re.search(
                r"CREATE\s+VIEW\s+(\S+)\s+AS", create_view_sql, re.IGNORECASE
            )
            if match:
                rename_map_table[match.group(1).lower()] = info["table_name"]

        rename_map_col = {}
        for info in renamed_infos:
            for original_col, renamed_col in info["column_mapping"]:
                rename_map_col[renamed_col.lower()] = original_col

        sorted_renamed_cols = sorted(rename_map_col.keys(), key=len, reverse=True)

        for renamed_col in sorted_renamed_cols:
            escaped_renamed_col = re.escape(renamed_col)

            col_pattern = re.compile(
                rf"(?<![A-Za-z0-9_'\".])"        
                rf"(?:`?(?P<alias>[A-Za-z0-9_]+)`?\.)?"  
                rf"`?(?P<col>{escaped_renamed_col})`?"  
                rf"(?![A-Za-z0-9_'\".])",       
                flags=re.IGNORECASE
            )

            def replace_col(m):
                alias = m.group('alias')
                col_lower = m.group('col').lower()
                original_col = rename_map_col[col_lower]
                orig_col_quoted = self.quote_if_needed(original_col)

                if alias:
                    alias_quoted = self.quote_if_needed(alias)
                    return f"{alias_quoted}.{orig_col_quoted}"
                else:
                    return orig_col_quoted

            sql_query = re.sub(col_pattern, replace_col, sql_query)

        return sql_query    
    
    def decompose_to_base_table_uv(self, sql_query: str, db_id: str) -> str:
        unified_info = self.setting.unified_view.get(db_id, None)
        if not unified_info:
            return sql_query

        join_steps = unified_info.get('join_steps', [])
        col_mapping = unified_info.get('column_mapping', [])

        from_clauses = []
        table_alias_map = {}

        for step in join_steps:
            tname = step['table_name']
            alias = step['alias']
            jtype = step['join_type']        
            conds = step['join_conditions']  
            parent = step['parent_table']

            table_alias_map[tname] = alias

            if jtype == 'FROM':
                from_clauses.append(f"FROM {tname} {alias}")
            elif jtype.upper() == 'INNER JOIN':
                on_list = []
                for cond in conds:
                    left_alias = table_alias_map.get(cond['left_table'], cond['left_table'])
                    right_alias = table_alias_map.get(cond['right_table'], cond['right_table'])
                    on_list.append(f"{left_alias}.{cond['left_col']} = {right_alias}.{cond['right_col']}")
                on_str = " AND ".join(on_list) if on_list else "1=1"
                from_clauses.append(f"INNER JOIN {tname} {alias} ON {on_str}")
            elif jtype.upper() == 'LEFT JOIN':
                on_list = []
                for cond in conds:
                    left_alias = table_alias_map.get(cond['left_table'], cond['left_table'])
                    right_alias = table_alias_map.get(cond['right_table'], cond['right_table'])
                    on_list.append(f"{left_alias}.{cond['left_col']} = {right_alias}.{cond['right_col']}")
                on_str = " AND ".join(on_list) if on_list else "1=1"
                from_clauses.append(f"LEFT JOIN {tname} {alias} ON {on_str}")
            else:
                from_clauses.append(f"{jtype} {tname} {alias}")

        if not from_clauses:
            base_from_clause = "-- (No base table found)"
        else:
            base_from_clause = "\n".join(from_clauses)

        col_map = {}
        for (orig_table, orig_col, new_col) in col_mapping:
            base_alias = table_alias_map.get(orig_table, orig_table)
            col_map[new_col.lower()] = (base_alias, orig_col)

        unified_view_pattern = re.compile(
            r"(?i)(FROM|JOIN)\s+(unified_view)\s+(?P<alias>[A-Za-z0-9_]+)?"
        )

        def _replace_unified_view(m):
            return base_from_clause

        new_sql = re.sub(unified_view_pattern, _replace_unified_view, sql_query)
        sorted_renamed_cols = sorted(col_map.keys(), key=len, reverse=True)

        for renamed_col in sorted_renamed_cols:
            escaped = re.escape(renamed_col)

            col_pattern = re.compile(
                rf"(?:`?(?P<alias>[A-Za-z0-9_]+)`?\.)?`?(?P<col>{escaped})`?",
                flags=re.IGNORECASE
            )

            def _callback(m):
                alias_part = m.group('alias')  
                (base_alias, orig_col) = col_map[renamed_col]
                return f"{self.quote_if_needed(base_alias)}.{self.quote_if_needed(orig_col)}"

            new_sql = re.sub(col_pattern, _callback, new_sql)

        return new_sql
    
    def decompose_to_base_table(self, sql_query, db_id, v_type):

        if v_type == "rv":
            sql_query = self.decompose_to_base_table_rv(sql_query, db_id)
        elif v_type == "uv":
            sql_query = self.decompose_to_base_table_uv(sql_query, db_id)
       
        return sql_query

    